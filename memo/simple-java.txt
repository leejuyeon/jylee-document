
객체지향

OOP
S	SRP	
단일 책임 원칙 (Single responsibility principle)
한 클래스는 하나의 책임만 가져야 한다.
O	OCP	
개방-폐쇄 원칙 (Open/closed principle)
“소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.”
L	LSP	
리스코프 치환 원칙 (Liskov substitution principle)
“프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라.
I	ISP	
인터페이스 분리 원칙 (Interface segregation principle)
“특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”[4]
D	DIP	
의존관계 역전 원칙 (Dependency inversion principle)
프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”[4] 의존성 주입은 이 원칙을 따르는 방법 중 하나다.


-----------------------------------------------------

spring

하나의 컨테이너
Ioc/DI기반


Ioc 제어 역전

DI 의존성 주입



-----------------------------------------------------

comparable, compartor 의 차이
- comparable : 자연스러운 순서로 정렬할 때 사용
- compartor : 원하는 대로 정렬 순서를 지정하고 싶은 곳에서 사용


삽입정렬에서 반환하는 리스트는 LinkedList 클래스의 인스턴스


자바 표준 라이브러리에 있는 몇몇 정렬 알고리즘은 리스트의 크기에 따라 다르게 구현 되어 있다.
작은 리스트는 삽입 정렬을 이용하지만 지정된 크기가 넘어가면 병합 정렬을 이용한다.

List를 사용하기 전에는 애플리케이션의 성능이나 메모리 사용량과 밀접한 관계가 있기 때문에 잘 고려하여 사용해야 함


arrayList 클래스는 크기를 지정하지 않는다면 기본 크기 10
원소로 가득한 배열에 새로운 원소를 추가할 때마다 ArrayList는 자동으로 더 큰 배열을 재할당 --> 시간이 더 소요되며 더 큰 메모리 용량을 소모
배열 크기 재할당은 단방향으로 이루어진다 -> 시작 위치와 가까운 곳에 원소를 추가할 수록 연산량이 늘어남
ArrayList클래스는 원소를 삭제해도 배열 크기가 줄어들지 않기 때문에 원소 개수가 계속 변경되는 리스트라면 ArrayList보단 LinkedList 클래스로 생성하는 것이 더 적합
ArrayList 원소에 랜덤접근 할 수 있어야 하거나 리스트 크기가 클 수록 사용하면 좋음
LinkedList 리스트의 첫부분이나 중간에 원소를 삽입/삭제 해야할 일이 많다면 사용하기 좋음 (스택처럼)

arrayList는 List와 Queue를 구현한 것

간단히 설명하면 리스트는 인터페이스이고 ArrayList, LinkedList 들은 List에 상속된 클래스들입니다!

Queue
선입선출


Map
List와 달리 Collection 인터페이스를 구현하지 않는다는 차이
key-value 형태로 key를 통해 value를 찾을 수 있음

	HashMap
	--> 동일하지 않은 객체들이 같은hashCode 메서드 값을 반환할 수도 있는 상황 --> 다른 객체가 같은 해시 테이블에 들어가는 상황 발생
	=> 두번째 해시 함수를 갖는 것이 필요.
	두번째 해시함수는 값을 삽입하려 할 때 테이블의 위치에 이미 다른 값이 있으면 오프셋 방식으로 해당 값이 삽입 될 위치를 다시 계산한다.
	=> 각 테이블의 원소에 대한 값들의 리스트를 저장하고 같은 테이블 인덱스와 연결되는 모든 텡블 키를 리스트의 값으로 추가하는 것

	
동일성 == / hashCode : 객체가 동일한 객체인지
동등성 equals() : 객체 내부의 값이 동일한지 확인
객체의 동등 비교를 위해서는 equals와 hashcode 오버라이딩 필요





디자인패턴

	- Builder 패턴 
		-> 객체를 생성할 때 필수 속성들과 선택 속성들이 많을 때
		좀 더 직관적으로 객체를 생성할 수 있도록 도와주는 패턴
	
	- 스트레티지 패턴
		-> 지정된 알고리즘의 세부 구현을 변경할 필요 없이 쉽게 교환할 수 있게 해주는 디자인 패턴
		실행중이라도 구현된 알고리즘을 교환할 수 있으므로 의존성주입(DI)에 자주 사용
		실행하기 전까지 어떤 구현을 사용할지 결정을 미룰 수 있다는 점 
		스프링 프레임워크에서 주로 사용함
		--> 빈 생성할 때 param으로 받아오는 부분인것같음
		
	- 템플릿메서드 패턴
		-> 알고리즘의 일부 또는 전부를 하위 클래스에 구현하거나 위임하는데 사용
		즉, 공통으로 사용하는 알고리즘은 부모 클래스에서 정의하고 특정 부분에서 사용하는 알고리즘은 하위 클래스에서 수행하도록 설계
		java interface-impl
		
	- 데커레이터 패턴
		-> 특정 객체 기능을 설정하거나 변경할 수 있게 함
		JVM 외부 소스를 읽고 저장하는 자바의 기본 입/출력 클래스는 데커레이터패턴 확장 
		-> 외부에서 파일 읽고 다시 저장할 때 효율적으로 하기 위해 연계해서 사용(InputStream, OutputStream)
		
	- 플라이웨이트 패턴
		-> 몇 개의 객체에 많은 값을 공유해야할 때 유용
		
	- 싱글턴 패턴
		-> 클래스가 오직 하나의 인스턴스만 생성한다는 것을 보장하는 패턴으로
		보통 db나 웹 서비스 같이여러 서드파티에서 해당 인스턴스에 접근할 수 있는 유일한 지점을 만드는데 사용
		다수 서비스에서 보내는 연결요청을 한 곳에서 쉽게 관리하고 설정할 수 있다는 장점
		인스턴스는 제일 처음 필요로 하는 경우에 생성. 싱글턴 인스턴스를 Enum을 타입으로 생성하면 하나의 인스턴스만 생성하는 것을 보장
		싱글턴 인스턴스로 생성할 경우 작은 코드단위로 분리하여 테스트하기 어려움
		
		

-----------------------------------------------------

JAVA

타입
- 원시타입 : boolean,short, int, long, float 등등 : null이 될 수 없음
- 참조타입 : 원시타입을 제외한 모든 변수들

String 객체의 값을 변경할 수 있는가? ㄴㄴ
STring 객체의 값을 변경하는 것처럼 보이는 모든 메서드가 실제로는 String 인스턴스를 반환
String을 포함하여 Integer, Double, Charater, BigInteger 같은 클래스들도 불변 클래스

final
- 변수정의에서 지정된 값처럼 일단 할당되고 나면 메모리 위치가 변경되지 않는다.

static
- static 메서드와 변수는 클래스 내부에 정의하지만 인스턴스에 속하지 않는다. 

객체 접근자
클래스의 캡슐화된 상태와 인스턴스 행동을 조정하는 메서드의 접근을 제어하는 역할
	- private : 같은 클래스의 모든 인스턴스에서 접근 가능. 하위 클래스에서 접근 불가
	- default : 같은 패키지의 모든 클래스에서 접근 가능
	- protected 모든 하위 클래스에서 접근 가능
	- public : 어디서든 접근 가능
	
다형성
- 행동의 특정 타입에 대한 정의를 만들 수 있게 하고 행동을 구현하는 수많은 다른 클래스를 갖게 한다.

상속
부모 클래스에서 클래스의 행동과 정의를 가져다 사용할 수 있게 한다.
새로운 행동을 추가하거나 새로운 타입에 대한 행동을 오버라이드 할 수 있다.

제네릭
매개변수화된 타입. 컬렉션 클래스에서 제네릭을 사용했을 때 컴파일러는 특정 타입만 포함될 수 있게 컬렉션을 제한한다.
제네릭을 사용하면 실행할 때 발생할 수 있는 잠재적인 모든 예외가 실제 컴파일러 에러로 이어지기 때문에 개발에 좀 더 유용
원시타입은 제네릭타입정의에 사용할 수 없다. (--> 원시타입은 null 할당안되기때문에)

와일드카드 '?'
컴파일러에게 A클래스와 그를 확장한 모든 클래스에서 실행될 수 있도록 A클래스를 확장한 모든 인스턴스를 제네릭으로 받아서 사용할 수 있게하라고 전달

언박싱
컴파일러에서 제공하는 연산으로 Float, Integer, Boolean 과 같이 박스된 참조타입을 자신들의 원시 타입인 float, int, boolean 타입으로 변경하는것

예외처리
Throwable는 Error와 Exception 두개의 하위 클래스를 가지고 있는데
대개 Exception을 사용하여 처리함. Error는 OutOfMemoryERror 또는 NoClassDefFoundError 처럼 프로그래머 스스로 복구 할 수 있는데 아님
예외에서는 runtime Exception과 checked exception 두가지로 구분
	- runtime exception
		-> nullPointException, ArrayIndevOutOfBoundsException같은 이슈들로 프로그래머가 사전방지해야함
	- checked exception
		-> 명시적으로 예외가 정의되어야 하며 메서드 호출자에게 전달하거나 try/catch/finally문으로 예외를 적절하게 처리해야 한다
=>runtime exception을 권장하는데 try/catch/finally문을 이용하면 간단한 메서드 호출에서도 많은 기본코드를 추가해야하고 유지보수도 어렵다.
스칼라같은 최신언어는 checked exception 배제하고 runtime exception 만 사용하게 한다.

연쇄예외
앞에서 예외를 처리할 때 새로운 예외를 처리하고 새 예외에 대한 참조를 추가하는 것으로 catch문에서 새로운 예외를 처리하는 것
		
java collection
list (linkedList, arrayList), set(treeSet)

java Map
hashMap

java8
람다, interface default method
- interface와 abstract
	- 추상클래스와 인터페이스는 인스턴스화 하는 것은 불가능하며, 구현부가 있는 메소드와 없는 메소드 모두 가질 수 있다는 점에서 유사하다.
	- 인터페이스에서 모든 변수는 기본적으로 public static final 이며, 모든 메소드는 public abstract 인 반면 
	- 추상클래스에서는 static 이나 final 이 아닌 필드를 지정할 수 있고, public, protected, private 메소드를 가질 수 있다.
	- 인터페이스를 구현하는 어떤 클래스는, 다른 여러개의 인터페이스들을 함께 구현할 수 있다. 
	추상클래스는 상속을 통해 구현되는데, 자바에서는 다중상속을 지원하지 않으므로 추상클래스를 상속받은 서브클래스는 다른 클래스를 상속받을 수 없다.
	
	
추상클래스, 인터페이스의 적절한 사용 케이스
추상클래스
관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우
추상클래스를 상속받은 클래스들이 공통으로 가지는 메소드와 필드가 많거나, public 이외의 접근제어자(protected, private) 사용이 필요한 경우
non-static, non-final 필드 선언이 필요한 경우. 즉, 각 인스턴스에서 state 변경을 위한 메소드를 선언할 수 있다.
인터페이스
서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우에 사용한다. 예를 들어, Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없는 경우가 대부분이다.
특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우.
다중상속을 허용하고 싶은 경우

----
자바8 부터는 인터페이스도 default 키워드를 사용하여 메소드의 구현부를 가질 수 있는데 꼭 추상클래스를 사용해야만 하나?
이때, 템플릿 메소드 내부에서 사용되는 메소드들에 대한 (구현은 하위클래스에서 하고) 외부에서의 호출을 막고 싶다면 추상클래스로 사용하는게 맞는 것 같다. 
추상클래스를 사용하면 protected, private 제어자를 지정할 수 있기 때문이다. (추상클래스가 같은 패키지 내에 있다면 protected 라도 접근 가능하지만, 
템플릿메소드패턴이 적용된 추상클래스는 라이브러리 형태로 외부패키지에서 제공되는 방식일 것이므로, 상속을 받지 않은 클래스에서는 호출하지 못하게 할 수 있다고 봐도 될 것 같다)

인터페이스는 기본적으로 변수필드는 public static final 이며, 모든 메소드는 public abstract 이므로 인터페이스로 구현할 경우, 
템플릿 메소드 내부에서만 호출되어야 할 메소드들이 public 제어자에 의해 의도치 않은 사용처에서 호출될 위험이 있다.

이때 또 생각해야 할 것은, 자바는 다중상속을 허용하지 않기 때문에 템플릿 메소드 패턴이 적용된 추상클래스를 구현한 서브클래스는 
다른 클래스를 상속받을 수 없다는 단점이 있다. 반면, 인터페이스로 템플릿 메소드 패턴을 구현했다면 다른 클래스를 상속 받을 수 있는 가능성을 열어둘 수 있다.

그러면 자바의 AbstractMap, AbstractSet 등은 왜 인터페이스가 아닌 추상클래스로 선언된 것일까? 이건 딱히 무슨 대단한 이유가 있다기 보다는… 
자바8 이전에 인터페이스는 구현체를 가질 수 없었기 때문이다.
----





		
Enum, Generic, iterator

java7->java8 차이

1. 람다 표현식(lambda expression) : 함수형 프로그래밍

2. 스트림 API(stream API) : 데이터의 추상화

3. java.time 패키지 : Joda-Time을 이용한 새로운 날짜와 시간 API
java.time 패키지
JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 처리를 수행했습니다.

하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(deprecated) 있습니다.

 

JDK 1.1부터 새롭게 제공된 Calendar 클래스는 날짜와 시간에 대한 정보를 얻을 수는 있지만, 다음과 같은 문제점을 가지고 있습니다.

 

1. Calendar 인스턴스는 불변 객체(immutable object)가 아니라서 값이 수정될 수 있습니다.

2. 윤초(leap second)와 같은 특별한 상황을 고려하지 않습니다.

3. Calendar 클래스에서는 월(month)을 나타낼 때 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다.

 

따라서 많은 자바 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 Joda-Time이라는 라이브러리를 함께 사용해 왔습니다.

 

Java SE 8 버전에서는 이러한 Joda-Time 라이브러리를 발전시킨 새로운 날짜와 시간 API인 java.time 패키지를 제공합니다.

java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 하위 패키지를 포함하고 있습니다.

 



Optional
옵셔널은 논란이 있는 클래스입니다. 
NPE 를 더 쉽게 다룰 수 있고, 다른 포스트에서 살펴볼 스트림과 함께 사용하면 간결하게 코딩할 수 있는 장점이 있습니다. 
하지만 처음부터 Option 을 지원한 Scala 와 다르게 이미 많은 코드가 옵셔널 없이 null 체크를 하고 있기 때문에 
개발자를 혼란스럽게 하고 기존 소스와 다른 코드 스타일을 만들 수 있어 부정적으로 보는 개발자들도 많습니다.





java8->java11 차이
- http/2 지원
- 람다에서 var 변수 지원
- 새로운 GC (ZGC)
- nest based access


--------------------------------------------------------------------------------------


JUnit

TDD(Test-Driven Development)
코드가 어떻게 작동하길 바라는지에 관한 예상이나 가정을 기반으로 짧은 실행을 반복하는 테스트를 만드는 절차
아키텍처를 개발할 때 지속적인 배포 모델을 구축할 수 있는 기반

junit4, 5의 차이
4는 java5 기반, 5는 java8 기반으로 5에서는 java8의 람다 사용 가능
4는 단일 jar, 5는 3개의 모듈로 나뉘어져있음



--------------------------------------------------------------------------------------


JVM

JVM의 메모리 구조
			static
			클래스
stack					heap
메서드					객체

stack은 기본값, 객체의 참조, 메서드가 저장되는 위치
	- 스택에 있는 변수의 생애주기는 코드의 스코프에 영향을 받는다
	- local value/parameter 와 같은
heap은 new로 생성된 인스턴스 변수들이 저장되는 위치
	- GC 또는 JVM 종료될 때 사라짐


GC
heap 영역에 메모리가 충분하지않다면 gc를 이용해 heap의 메모리를 재사용하려고 시도하지만 실패하면 OutMemoryError 발생 --> JVM 종료
기존에 할당된 메모리를 재 사용하는 매커니즘으로 가비지컬렉션을 사용하면 메모리를 직접 해체할 필요가 없다.
자바의 전통적인 gc는 mark-and-sweep 방식이다. gc가 작동될 때는 JVM의 모든 스레드가 정지되는데 이를 stop the world라고 한다.


JVM 튜닝
- heap 초기 메모리 지정 : -Xms
- heap 메모리 최대 : -Xmx

클래스와 string 상수를 많이 사용한다면 permanent (meta space)를 위한 pXX:Permsize, -XX:MaxPermSize 사용
java8에서는 아래처럼 변경 :
-XX:MaxMetaspaceSize=
-XX:MetaspaceSize=

perm과 metaspace의 차이 : 


java7->8 넘어갈 때 heap 영역 메모리 올려줘야함 --> java8에서는 heap에서 관리하는 데이터가 많아짐


------------------------------------------------

자바 직렬화
자바 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 
데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기합니다


JSON
최근에 가장 많이 사용하는 포맷으로 자바스크립트(ECMAScript)에서 쉽게 사용 가능하고, 다른 데이터 포맷 방식에 비해 오버헤드가 적기 때문에 때문에 인기가 많습니다.

--> “자바 직렬화 형태의 데이터 교환은 자바 시스템 간의 데이터 교환을 위해서 존재한다.”

자바 직렬화의 장점
자바 직렬화는 자바 시스템에서 개발에 최적화되어 있습니다. 복잡한 데이터 구조의 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화를 가능합니다. 물론 역직렬화도 마찬가지입니다.
   당연하게 보이는 장점 중에 하나지만 데이터 타입이 자동으로 맞춰지기 때문에 관련 부분을 큰 신경을 쓰지 않아도 됩니다.
   그렇게 역직렬화가 되면 기존 객체처럼 바로 사용할 수 있게 됩니다. 개발자 입장에서 상당히 편한 부분인거죠.
   
   
자바 직렬화는 언제(when) 어디서(where) 사용되나요?
JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영속화(Persistence)가 필요할 때 사용됩니다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송도 가능합니다. 
그리고 필요할 때 직렬화된 객체 데이터를 가져와서 역직렬 화하여 객체를 바로 사용할 수 있게 됩니다. 
그런 특성을 살린 자바 직렬화는 많은 곳에서 이용됩니다. 많이 사용하는 부분 몇 개만 이야기해보겠습니다.

서블릿 세션 (Servlet Session)
서블릿 기반의 WAS(톰캣, 웹로직 등)들은 대부분 세션의 자바 직렬화를 지원하고 있습니다.
물론 단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 되면 세션 자체가 직렬화가 되어 저장되어 전달됩니다. 
(그래서 세션에 필요한 객체는 java.io.Serializable 인터페이스를 구현(implements) 해두는 것을 추천합니다.) 
참고로 위 내용은 서블릿 스펙에서는 직접 기술한 내용이 아니기 때문에 구현한 WAS 마다 동작은 달라질 수 있습니다.

캐시 (Cache)
자바 시스템에서 퍼포먼스를 위해 캐시(Ehcache, Redis, Memcached, …) 라이브러리를 시스템을 많이 이용하게 됩니다.
자바 시스템을 개발하다 보면 상당수의 클래스가 만들어지게 됩니다. 예를 들면 DB를 조회한 후 가져온 데이터 객체 같은 경우 실시간 형태로 요구하는 데이터가 아니라면 메모리, 외부 저장소, 파일 등을 저장소를 이용해서 데이터 객체를 저장한 후 동일한 요청이 오면 DB를 다시 요청하는 것이 아니라 저장된 객체를 찾아서 응답하게 하는 형태를 보통 캐시를 사용한다고 합니다.
캐시를 이용하면 DB에 대한 리소스를 절약할 수 있기 때문에 많은 시스템에서 자주 활용됩니다. (사실 이렇게 간단하진 않습니다만 간단하게 설명했습니다.) 
이렇게 캐시 할 부분을 자바 직렬화된 데이터를 저장해서 사용됩니다. 물론 자바 직렬 화만 이용해서만 캐시를 저장하지 않지만 가장 간편하기 때문에 많이 사용됩니다.




자바 직렬화를 사용할 때에는 될 수 있으면 자주 변경되는 클래스의 객체는 사용 안 하는 것이 좋습니다. 변경에 취약하기 때문에 생각지도 못한 예외사항들이 발생할 가능성이 높습니다. 특히 역직렬 화가 되지 않을 때와 같은 예외처리는 기본적으로 해두는 것을 추천합니다. 
물론 직렬화 대상 클래스 변경과 같은 문제는 자바 직렬 화만 일어나는 문제는 아닙니다만 자바 직렬화 기술은 중간에 끼어들 여지가 없는 블랙박스에 가까워서 변경 부분에 취약한 문제가 존재합니다.


------------------------------------------------
dto / vo / dao / domain


- vo : read only
- dao : 데이터 접근을 목적
- dto : 데이터가 포함된 객체를 한 시스템에서 다른 시스템으로 전달하는 작업 
		vo와 차이는 co는 특정 비즈니스 값을 담은 객체이고 dto는 레이어간의 통신용도로 오가는 객체


vo == dao == domain 동일한 의미로 보면 될듯
실제 DB에 접근하는 객체

dto
계층간 데이터 교환을 위한 객체로 db에서 얻은 데이터(vo/dao/domain)를 service나 controller 등으로 보낼 때



------------------------------------------------

리액티브, 비동기
Reactive Streams
Reactor
Rx
위에가 다 같은 개념인가?

비동기
Flux Mono
Java9 Flow 

일단 저런거 배우기 전에, 짚고 넘어가야 할 게
토비 아저씨가 소개해줄 정도면 충분히 괜찮은 자료라고 보임
https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/

블록킹 vs 논블록킹
호출되는 함수가 바로 리턴하느냐 마느냐

동기 vs 비동기 
호출되는 함수의 작업 완료 여부를 누가 신경쓰느냐


Junit Thread Test
https://jangchulwoon.github.io/junit/2017/11/24/JUnitThread/
뭐야 결론이 왜이래 쓰다가 말았어
Junit쓰면서 비동기로 스레드 실행시키면 로그가 제대로 안 남는다
	1. Thread.sleep(10000)
	2. Thread.join 메소드
		a. 조인을 이용한다
		b. 이것도 블록킹 방식이다
	3. 유저 스레드 모드 대몬 스레드 모드
		a. 조인 join()
		b. forkJoin 이거랑도 관련이 있다고 한다
	4. Notify를 쓰고 Blocking을 사용하지 마라

교환법칙 결합법칙 

네트웍  I/O작업 
ms단위
Cpu 작업
ns 단위
같은 스레드에서 작업을 시키면 i/o 작업이 병목이 된다
대신 i/o 작업은 cpu 자원 소모량이 적다
따라서 i/o작업은 블록킹 시키지 않고 항상 별도 스레드로 처리한다
기본적인 사상, 우리가 쓰는 톰캣이 이렇게 되어 있음

스레드 스택 공간 java 최신? 버전의 경우 1메가의 스택공간(필수)
우리가 만든 작업은 kb에서 gb단위로 사용

따라서 스레드 개수를 늘리게 되면 (멀티 스레드 방식) 메모리 소모량이 매우 많다!
사실 이렇지는 않음, 스레드 풀을 두고 스레드 관리 (등등의 다양한 기법)

그리고 스레드 처리의 디버깅이 어렵다

필요성을 알아야 rxjava를 사용할 수 있다

람다  : interface with in/out generic
람다가 이해가 잘 안되면 그냥 syntatic sugar라고 생각하세요 당분간은

고계함수 :  add???Listener 형태로 만드는 것들 (인자로 함수 집어넣는거)
몇가지 표준화된 규격
	- filter, map, flatmap, reduce, forEach
Input Definition Factory : like List<InputType> <----- Observerble???

Laziness 람다식을 넣었을 때, 지연실행 된다??


이제 드디어 rxjava
Responsive Resilient Elastic MessageDriven
사용자의 요청에 응답해야 한다
에러나 실패에 대해서 견고하게 대처할 수 있어야 한다
부하에 대해서 탄력적으로 수용해야 한다
메세지 기반이다

 풀 방식 vs 푸시 방식
Iterable : pull, Observable : push

Spring Reactor, Reactive


----------------------------------------
트랜잭션

데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

ACID 속성

원자성 : 트랜잭션 내용들은 모두 적용되거나 하나도 적용되지 않아야 한다
일관성 : 트랜잭션 적용 후에 데이터베이스는 도메인에 있는 모든 요구 사항을 만족 시켜야한다
독립성 : 병렬실행 트랜잭션은 db에서 실행되는 유일한 트랜잭션으로 적용해서 따로 실행
지속성 : 트랜잭션이 커밋되면 내용은 영구히 적용되어야 한다


----------------------------------------
NoSql

관계형 디비가 아닌 반정규화에 의존하여 key-value 형태로 저장
대용량 데이터를 처리할 때 적합
MongoDB :데이터를 JSON 객체로 저장하고 같은 필드 전부를 다른 유사 객체와 공유하지 않는다.




----------------------------------------
http

웹 브라우저와 웹 서버간의 통신 규약

https
웹 통신 프로토콜인 HTTP의 보안이 강화된 버전
HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.



http2
http1.1의 성능을 개선시키는 것
http 헤더 압축
tcp 연결 하나로 여러 요청 다중화 처리
HTTP 1.x의 HOL blocking 문제 해결
	HOL(Head-Of-Line) 블로킹 이란 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
	
	
	
GET : 요청된 자원을 제공
POST : 요청된 자원을 생성(CREATE)한다. 새로 작성된 리소스인 경우 HTTP헤더 항목 Location : URI주소를 포함하여 응답. --> (create)
PUT : 내용 갱신 (update)
DELETE : 자원 삭제 (delete)
HEAD : get 요청과 비슷하지만 응답코드와 헤더만 반환 (대용량 자원 있는지 확인)


----------------------------------------
REST의 구체적인 개념
HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.